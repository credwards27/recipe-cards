/* app-manager.js
    
    Main application data manager. Application-wide data management and
    communication is controlled by this module.
*/

// Dependencies.
const {
    ipcMain: ipc,
    dialog,
    BrowserWindow
} = require("electron"),
    { promisify } = require("util"),
    fs = require("fs"),
    path = require("path"),
    readFileAsync = promisify(fs.readFile),
    { getWindow, getAllWindows } = require("app/back/window-manager.js"),
    LinkedList = require("app/all/linked-list.js"),
    Recipe = require("app/front/recipe.js"),
    RecipeNode = require("app/front/recipe-node.js"),
    immutable = require("app/all/immutable.js");

/* Application manager class.
*/
class AppManager {
    //
    // STATIC PROPERTIES
    //
    
    //
    // PROPERTIES
    //
    
    // Global app data state.
    _data = {
        // File handle for the currently opened recipe pack file.
        file: null,
        
        // LinkedList containing loaded recipe objects.
        recipes: new LinkedList()
    };
    
    // References to recipe objects, keyed by recipe ID.
    _recipeMap = {};
    
    /* Constructor for AppManager.
    */
    constructor() {
        immutable(this, "_data");
        immutable(this, "_recipeMap");
        
        ipc.on("open-file", this.ipcOpenFile);
        ipc.on("select-recipe", this.ipcSelectRecipe);
        ipc.on("print-recipe", this.ipcPrintRecipe);
        
        ipc.handle("get-current-recipes", this.ipcGetCurrentRecipes);
    }
    
    /* Destructor for AppManager.
    */
    destroy() {
        ipc.removeListener("open-file", this.ipcOpenFile);
        ipc.removeListener("select-recipe", this.ipcSelectRecipe);
        ipc.removeListener("print-recipe", this.ipcPrintRecipe);
        
        ipc.removeHandler("get-current-recipes");
    }
    
    //
    // STATIC METHODS
    //
    
    //
    // METHODS
    //
    
    /* Getter for _data.
        
        Returns the global application data store.
    */
    get data() {
        return this._data;
    }
    
    /* Getter for _recipeMap.
        
        Returns the recipe ID map.
    */
    get recipeMap() {
        return this._recipeMap;
    }
    
    /* Gets the list of loaded recipe objects.
        
        Returns the list of loaded recipe objects.
    */
    get recipes() {
        return this._data.recipes;
    }
    
    /* Gets a recipe node by recipe ID.
        
        id - Recipe ID or Recipe object in the list.
        
        Returns the node associated with the given recipe ID. If no recipe is
        found for the given ID, this will return undefined.
    */
    getRecipe(id) {
        id = id instanceof Recipe ? id.id : id;
        return this._recipeMap[id];
    }
    
    /* Loads recipe data.
        
        recipes - Array of raw recipe data.
    */
    loadRecipes(recipes) {
        if (!recipes) {
            return;
        }
        
        let recipeMap = this.recipeMap;
        
        // Removea all existing data
        this.recipes.removeAll(false, (r) => {
            delete recipeMap[r.id];
            r.destroy();
        });
        
        recipes = recipes instanceof Array ? recipes : [ recipes ];
        
        for (let i=0, l=recipes.length; i<l; ++i) {
            this.addRecipe(recipes[i], null);
        }
        
        this.emit("updated-recipe-list");
    }
    
    /* Adds a recipe to the list.
        
        recipe - Raw recipe data to add to the list.
        
        after - Optional existing recipe ID or RecipeNode object in the list,
            after which to add the new recipe. If omitted, the new recipe will
            be appended to the end of the list.
        
        publishUpdate - True to publish the full list update change to IPC
            listeners, false otherwise. Defaults to false. Does not affect
            single-item IPC message.
        
        Returns the list node containing the newly-added recipe.
    */
    addRecipe(recipe, after, publishUpdate) {
        if (!(recipe instanceof RecipeNode)) {
            recipe = new RecipeNode(recipe);
        }
        
        let node;
        
        node = this.recipes.insert(
            recipe,
            this.getRecipe(after) || this.recipes.last(true)
        );
        
        this._recipeMap[recipe.id] = node;
        
        this.emit("added-recipe", recipe.serialize());
        
        if (publishUpdate) {
            this.emit("updated-recipe-list");
        }
        
        return node;
    }
    
    /* Removes a recipe from the list.
        
        recipe - Recipe ID or RecipeNode object to remove from the list. The
            recipe node must belong to the app's recipe list in order to remove
            it.
        
        publishUpdate - See AppManager.addRecipe().
    */
    removeRecipe(recipe, publishUpdate) {
        let node = this.getRecipe(recipe);
        
        if (!node) {
            return;
        }
        
        recipe = this.recipes.remove(node);
        delete this._recipeMap[recipe.id];
        
        ipc.emit("removed-recipe", recipe.serialize());
        
        if (publishUpdate) {
            ipc.emit("updated-recipe-list");
        }
    }
    
    /* Emits an IPC event to all existing windows.
        
        channel - IPC channel for which to emit an event.
        ...customArgs - Custom arguments to send with the event (appended after
            the channel's required arguments, if any).
    */
    emit(channel, ...customArgs) {
        let windows = BrowserWindow.getAllWindows(),
            args;
        
        switch (channel) {
            case "updated-recipe-list":
                args = [ this.recipes.toArray(r => r.serialize()) ];
                break;
            
            case "added-recipe":
            case "removed-recipe":
            case "loaded-file":
            case "loaded-file-error":
            case "selected-recipe":
            case "print-recipe":
                args = [];
                break;
            
            default:
                throw new Error(`Channel '${channel}' is not supported.`);
        }
        
        args.push(...customArgs);
        
        for (let i=0, l=windows.length; i<l; ++i) {
            windows[i].webContents.send(channel, ...args);
        }
    }
    
    /* IPC 'open-file' handler.
        
        event - IPC event.
    */
    ipcOpenFile = async (event) => {
        let fileData = {
            canceled: false,
            data: ""
        },
            win = BrowserWindow.fromWebContents(event.sender),
            result;
        
        // Show the file dialog
        try {
            result = await dialog.showOpenDialog(win, {
                buttonLabel: "Open Recipes",
                filters: [
                    {
                        name: "Recipe Packs",
                        extensions: [ "recipe-pack" ]
                    },
                    {
                        name: "All Files",
                        extensions: [ "*" ]
                    }
                ],
                properties: [ "openFile" ]
            });
        }
        catch (e) {}
        
        // Stop early if open operation was canceled
        if (result.canceled || !result.filePaths.length) {
            return;
        }
        
        // Read the file
        try {
            fileData.data = await readFileAsync(result.filePaths[0], "utf8");
        }
        catch (e) {
            let fileName = result.filePaths[0].match(
                new RegExp(`[^${path.sep}]+$`)
            );
            
            fileName = fileName ? fileName[0] : "";
            
            this.emit(
                "loaded-file-error",
                `File '${fileName}' could not be opened.`
            );
            
            return;
        }
        
        // Load the file.
        try {
            fileData.data = JSON.parse(fileData.data);
        }
        catch (e) {
            this.emit("loaded-file-error", "Recipe file format is invalid.");
            return;
        }
        
        this.loadRecipes(fileData?.data?.recipes);
        
        this.emit("loaded-file", fileData?.data);
        this.emit("selected-recipe", undefined);
    };
    
    /* Gets the current list of recipes.
        
        event - IPC event.
    */
    ipcGetCurrentRecipes = (event) => {
        return this.recipes.toArray(r => r.serialize());
    };
    
    /* Loads a specific recipe.
        
        event - IPC event.
        id - Recipe ID to load.
    */
    ipcSelectRecipe = (event, id) => {
        let recipe = this.getRecipe(id);
        
        this.emit("selected-recipe", recipe?.data?.serialize());
    };
    
    /* Triggers the print dialog for the currently selected recipe.
        
        event - IPC event.
    */
    ipcPrintRecipe = async (event) => {
        let { instance: win } = await getWindow("output");
        
        win.webContents.print();
    };
}

module.exports = AppManager;
