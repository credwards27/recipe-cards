/* card.js
    
    Base class for recipe cards with shared functionality.
*/

// Dependencies.
const { PureComponent } = require("react"),
    clamp = require("app/all/clamp.js");

/* Recipe card base class.
*/
class Card extends PureComponent {
    //
    // STATIC PROPERTIES
    //
    
    //
    // PROPERTIES
    //
    
    // Element within the component that supports text resizing.
    _resizeElem = null;
    
    /* Unmount handler.
    */
    componentWillUnmount() {
        this._resizeElem = null;
    }
    
    /* Update handler.
    */
    componentDidUpdate() {
        this.resizeText();
    }
    
    //
    // STATIC METHODS
    //
    
    //
    // METHODS
    //
    
    /* Resizes text and spacing to fit the card wrapper.
    */
    resizeText() {
        // Stop if the component has not defined a resize element
        if (!this._resizeElem) {
            return;
        }
        
        let elem = this._resizeElem,
            parent = elem.parentElement,
            elemHeight = this.getHeight(elem),
            parentHeight = this.getHeight(parent),
            font = this.props.font,
            line = this.props.line,
            siblingHeight, maxHeight;
        
        // Get the combined height of the resize element's siblings
        siblingHeight = Array.prototype.map.call(parent.children, (e) => {
            // Don't count the resize element's height
            if (e === elem) {
                return 0;
            }
            
            let style = getComputedStyle(e),
                mt = this.parsePx(style.marginTop),
                mb = this.parsePx(style.marginBottom);
            
            return e.clientHeight + mt + mb;
        }).reduce((total, curr) => {
            return total + curr;
        }, 0);
        
        maxHeight = parentHeight - siblingHeight;
        
        if (maxHeight < 1) {
            // Can't do anything with this
            return;
        }
        
        if (elemHeight > maxHeight) {
            // Shrink to fit
            while (elemHeight > maxHeight) {
                let vals = this.step("down", elem, font, line);
                
                if (!vals) {
                    // Reached minimum, stop
                    break;
                }
                
                elemHeight = this.getHeight(elem);
            }
        }
        else if (elemHeight < maxHeight) {
            // Fill to fit
            let lastStep;
            
            while (elemHeight < maxHeight) {
                let vals = this.step("up", elem, font, line);
                
                if (!vals) {
                    lastStep = null;
                    break;
                }
                
                lastStep = vals;
                elemHeight = this.getHeight(elem);
            }
            
            if (lastStep) {
                // Adjustment did not reach limit, last step was one too many
                this.step("down", elem, font, line);
            }
        }
    }
    
    /* Gets the inner content area height of an element (excluding padding and
        borders).
        
        elem - Element for which to retrieve height.
    */
    getHeight(elem) {
        let style = getComputedStyle(elem),
            pt = this.parsePx(style.paddingTop),
            pb = this.parsePx(style.paddingBottom),
            bt = this.parsePx(style.borderTopWidth),
            bb = this.parsePx(style.borderBottomWidth),
            height = elem.clientHeight - (pt + pb + bt + bb);
        
        return height > 0 ? height : 0;
    }
    
    /* Resizes down one step.
        
        dir - Direction to step ('up' or 'down').
        elem - Element to resize.
        font - Font size object with 'max' and 'min' values.
        line - Line height object with 'max' and 'min' values.
        
        Returns an object containing both the original and the new font size and
        line height values, or false if no change was made.
    */
    step(dir, elem, font, line) {
        let { fontSize, lineHeight } = getComputedStyle(elem),
            fontStep = 0.5,
            lineStep = 0.1,
            tol = 0.00001,
            adjustFont = false,
            adjustLineHeight = false,
            bound, oppBound, fontBound, lineBound, oppLineBound, newFontSize,
            newLineHeight;
        
        // Get directional values
        switch (dir) {
            case "up":
                bound = "max";
                oppBound = "min";
                dir = 1;
                break;
            
            case "down":
                bound = "min";
                oppBound = "max";
                dir = -1;
                break;
            
            default:
                throw new Error(`Direction '${dir}' is invalid, must be ` +
                    "'up' or 'down'.");
        }
        
        fontBound = font[bound];
        lineBound = line[bound];
        oppLineBound = line[oppBound];
        
        fontSize = clamp(this.parsePx(fontSize), fontBound, tol);
        lineHeight = clamp(this.parsePx(lineHeight) / fontSize, lineBound, tol);
        
        newFontSize = fontSize + (fontStep * dir);
        newLineHeight = lineHeight + (lineStep * dir);
        
        // Limit to bound
        if (1 === dir) {
            // Up, limit to max
            newFontSize = newFontSize <= fontBound ? newFontSize : fontBound;
            
            newLineHeight = newLineHeight <= lineBound ?
                newLineHeight : lineBound;
        }
        else {
            // Down, limit to min
            newFontSize = newFontSize >= fontBound ? newFontSize : fontBound;
            
            newLineHeight = newLineHeight >= lineBound ?
                newLineHeight : lineBound;
        }
        
        newFontSize = clamp(newFontSize, fontBound, tol);
        newLineHeight = clamp(newLineHeight, lineBound, tol);
        
        // Determine which adjustment to make, if any
        adjustFont = 1 === dir ?
            (fontSize < fontBound) : (fontSize > fontBound);
        
        adjustLineHeight = 1 === dir ?
            (lineHeight < lineBound) : (lineHeight > lineBound);
        
        // Apply change
        if (adjustLineHeight) {
            elem.style.lineHeight = newLineHeight;
        }
        else if (adjustFont) {
            elem.style.fontSize = `${newFontSize}px`;
            elem.style.lineHeight = newLineHeight = oppLineBound;
        }
        else {
            return false;
        }
        
        return {
            font: {
                new: newFontSize,
                prev: fontSize
            },
            line: {
                new: newLineHeight,
                prev: lineHeight
            }
        };
    }
    
    /* Parses a computed pixel value to extract the numerical value.
        
        val - Computed CSS pixel value string to parse.
        
        Returns a copy of the object containing parsed values.
    */
    parsePx(val) {
        return parseFloat(val.trim().replace(/px$/, ""));
    }
    
    /* Virtual render method, must be overridden in a child class.
    */
    render() {
        throw new Error("Card class cannot be instantiated directly.");
    }
}

module.exports = Card;
